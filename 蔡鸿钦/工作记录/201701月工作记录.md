###20170101星期日工作记录
####这是今天的内容
#####1、修复了篮框移动时出现的异常
#####2、遇到的问题
```javascript
//创建用于检测的左端点，并将其设置为不可见
this.left = game.add.sprite(this.basket.x - this.basket.width / 2, this.basket.y - this.basket.height 			/ 2, 'left');
this.left.anchor.set(1, 0);
//固定左端点的大小
this.left.width = this.left.height = 10;
game.physics.enable(this.left, Phaser.Physics.ARCADE);
this.left.body.immovable = true;
//设置不可见
this.left.visible = false;

//创建用于检测的左端点，并将其设置为不可见
this.right = game.add.sprite(this.basket.x + this.basket.width / 2, this.basket.y - this.basket.height / 2, 'right');
this.right.anchor.set(0, 0);
//固定右端点的大小
this.right.width = this.right.height = 10;
game.physics.enable(this.right, Phaser.Physics.ARCADE);
this.right.body.immovable = true;
//设置不可见
this.right.visible = false;
```
#####然后，在this.update函数中，让this.left和this.right移动
```javascript
//在开始游戏的时候开始移动
if(this.titleGroup.visible)
{
    if(! this.hasChanged)
    {
        gameSpeed = Math.floor(score / 10);
        this.left.body.velocity.x = gameSpeed*50;
        this.right.body.velocity.x = gameSpeed*50;
        this.board.body.velocity.x = gameSpeed*50;
        this.basket.body.velocity.x = gameSpeed*50;
    }
    if(this.board.left <= 0 && !this.change)
    {
        gameSpeed = Math.floor(score / 10);
        this.left.body.velocity.x = gameSpeed*50;
        this.right.body.velocity.x = gameSpeed*50;
        this.board.body.velocity.x = gameSpeed*50;
        this.basket.body.velocity.x = gameSpeed*50;
        this.change = true;
        this.hasChanged = true;
    }
    if(this.board.right >= game.world.width && !this.change)
    {
        gameSpeed = -Math.floor(score / 10);
        this.left.body.velocity.x = gameSpeed*50;
        this.right.body.velocity.x = gameSpeed*50;
        this.board.body.velocity.x = gameSpeed*50;
        this.basket.body.velocity.x = gameSpeed*50;
        this.change = true;
        this.hasChanged = true;
    }
    if (this.board.left > 0 && this.board.right < game.world.width) 
    {
        this.change = false;
    }
}
```
#####这里，this.left、this.right和this.basket应该是一起移动，但是，有时候会出现在this.left和this.right的原位置也能发生碰撞的异常，去掉下面这两句代码之后，则异常消失，还不清楚是什么原因造成的
```javascript
this.left.visible = false;

this.right.visible = false;
```
#####3、解决问题的方法
#####使用了另外一种方法制造出this.left和this.right不可见的效果，就是把其他组件移到this.left和this.right上方，要注意移动组件的上下层逻辑关系
```javascript
//把其他组件上移，this.left和this.right在最底层
//通过这种方法让this.left和this.right不可见
this.bg.bringToTop();
this.board.bringToTop();
this.basket.bringToTop();
this.oneScore.bringToTop();
this.twoScore.bringToTop();
this.bottom.bringToTop();
```

###20170110工作记录
####这是今天的内容
#####1、不使用phaser的collide函数，自定义碰撞检测函数，使得球和两个碰撞监测点的碰撞更为自然
```javascript
//使用overlap来给球和左右端点碰撞的时候添加旋转效果
//自定义碰撞函数
game.physics.arcade.overlap(this.ball, this.left, function(){
    game.add.tween(this.ballSprite).to({angle: this.ballSprite.angle - 360}, 1000, null, true, 0, 0, false);
    this.hit = true;
    self.hit.play();
    //用于计算碰撞后球的速度
    var leng = Math.sqrt((this.ball.x - this.left.x) * (this.ball.x - this.left.x) 
        + (this.ball.y - this.left.y) * (this.ball.y - this.left.y));
    var veloc = this.ball.body.velocity.y;
    //碰撞的时候，x方向上的速度和y方向上的速度减少50，模拟能量损失
    veloc = veloc - 70 / 604 * window.innerHeight<200/ 604 * window.innerHeight?
        200 / 604 * window.innerHeight:veloc - 70 / 604 * window.innerHeight;

    this.ball.body.velocity.x = veloc * (this.ball.x - this.left.x) / leng;
    //这里为了增加碰撞后的入篮率，将碰撞后x方向上的速度设置为最少30 / 604 * window.innerHeight，30这个参数可变
    var x = Math.abs(this.ball.x - this.left.x) < 30 / 604 * window.innerHeight?
        (this.ball.x - this.left.x) / Math.abs(this.ball.x - this.left.x) * 30 / 604 * window.innerHeight:this.ball.x - this.left.x;
    this.ball.body.velocity.x = veloc * x / leng;
    this.ball.body.velocity.y = veloc * (this.ball.y - this.left.y) / leng;
}, null, this);

game.physics.arcade.overlap(this.ball, this.right, function(){
    game.add.tween(this.ballSprite).to({angle: this.ballSprite.angle - 360}, 1000, null, true, 0, 0, false);
    this.hit = true;
    self.hit.play();
    //用于计算碰撞后球的速度
    var leng = Math.sqrt((this.ball.x - this.right.x) * (this.ball.x - this.right.x) 
        + (this.ball.y - this.right.y) * (this.ball.y - this.right.y));
    var veloc = this.ball.body.velocity.y;
    //碰撞的时候，x方向上的速度和y方向上的速度减少50，模拟能量损失
    veloc = veloc - 70 / 604 * window.innerHeight<200/ 604 * window.innerHeight?
        200 / 604 * window.innerHeight:veloc - 70 / 604 * window.innerHeight;

    this.ball.body.velocity.x = veloc * (this.ball.x - this.right.x) / leng;
    //这里为了增加碰撞后的入篮率，将碰撞后x方向上的速度设置为最少30 / 604 * window.innerHeight，30这个参数可变
    var x = Math.abs(this.ball.x - this.right.x) < 30 / 604 * window.innerHeight?
        (this.ball.x - this.right.x) / Math.abs(this.ball.x - this.right.x) * 30 / 604 * window.innerHeight:this.ball.x - this.right.x;
    this.ball.body.velocity.x = veloc * x / leng;
    this.ball.body.velocity.y = veloc * (this.ball.y - this.right.y) / leng;
}, null, this);
```
#####2、修改了球的重力以及固定速度等参数

###20170111工作记录
####这是今天的内容
#####1、重写了根据手指滑动方向设置球抛出速度的函数
```javascript
//手指滑动结束之后调用的函数
this.bounce = function(x1, y1, x2, y2, ball, ballSprite)
 {
     //滑动手指结束之后再给球添加重力和速度
     
     ball.body.gravity.y = gravity;
     var length = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
     //计算出抛出去的角度，根据角度来设置左右方向上的速度
     var rateX = (x2 - x1) / length / 2;
     var rateY = (y2 - y1) / length;
     //在这里设置左右方向的速度
     //velocity是球的固定速度
     ball.body.velocity.x = velocity * rateX;
     ball.body.velocity.y = velocity * rateY;
     if(-ball.body.velocity.y < 2420 / 604 * window.innerHeight)
     {
         ball.body.velocity.y = -2420;
     }

     tween = game.add.tween(ballSprite);
     tween.to({angle: ballSprite.angle - 360}, 1000, null, true, 0, -1, false);

     self.shot.play();
}
```
#####2、更改需求，每次投完篮之后球重置的位置随机
```javascript
// 篮球成功入篮，一次投篮结束
this.reset = function() {
    //设置定时器，在一秒后执行所有重置操作                    
    game.time.events.add(1000, function(){
        //防止调用太多次reset函数
        if(!this.hasReseted)
        {
            //调用第一次reset函数之后，就无法再调用
            this.hasReseted = true;

            //把得分提示设置为不可见
            this.twoScore.visible = false;
            this.oneScore.visible = false;
            //恢复得分提示的坐标
            this.twoScore.y = this.board.y - this.board.height / 2;
            this.oneScore.y = this.board.y - this.board.height / 2;
            
            //复原影子的状态
            this.bottom.y = game.world.height - 50;
            this.bottom.height = this.bottomHeight;
            this.bottom.width = this.bottomWidth;

            //复原球的图片
            this.ballSprite.x = (game.world.width - this.ballWidth) * Math.random() + this.ballWidth / 2;
            this.ballSprite.y = this.bottom.y - this.ballHeight / 2;
            this.ballSprite.width = this.ballWidth;
            this.ballSprite.height = this.ballHeight;

            //复原影子的状态
            this.bottom.x = this.ballSprite.x;
            

            //复原球的状态
            this.ball.body.gravity.y = 0;
            this.ball.body.velocity.x = 0;
            this.ball.body.velocity.y = 0;
            this.ball.width = this.ballWidth;
            this.ball.height = this.ballHeight;
            this.ball.x = this.ballSprite.x;
            this.ball.y = this.ballSprite.y;
            this.ballSprite.bringToTop();

            //复原各类状态
            isBounced = false;
            this.isScored = false;
            this.hit = false;
        }
    }, this);
    //开启定时器
    game.time.events.start();
};

```
#####3、给可以替换的素材做适配
#####4、开始准备上线

###20120112工作记录
####这是今天的内容
#####1、根据少龙的要求修改了投篮比赛的文案
#####2、修复了把背景图换成纯色时出现不加载背景的bug
```javascript
// 创建游戏背景
//解决更换背景为纯色时，不加载背景的问题
if(self.config['game']['bg'].indexOf('#') == 0){
	 game.stage.backgroundColor = self.config['game']['bg'];
} else {
	 this.bg = game.add.image(0, 0, "bg");
	 this.bg.width = self.canvasSize.width;
	 this.bg.height = self.canvasSize.height;
}
```
######3、完成内网测试，把代码push到24haowan_game_tpl仓库，等待测试结束把投篮比赛放到外网上进行测试
