###20161210星期六工作记录
#### *这是今天的内容。
####*上午
#####1、复习了智能社视频教程关于DOM部分内容；
#####2、咨询了分配给我做的小游戏策划的一些细节；
#####3、仔细看了一遍策划，大概地了解了一下做这个小游戏可能需要用到的一些知识；

####*下午
#####1、继续看智能社的视频教程；
#####2、现在已经看到了第22集，其中略过了18、19这两集，因为讲的是如何利用之前讲的一些知识来实现一个页面效果；


###20161213星期二工作记录
####这是今天的内容
#####上午
#####1、把视频笔记整理了一遍
#####2、重新熟悉了一下忘得差不多的phaser的一些基本用法

#####下午
#####1、开始做分配给我的投掷类小游戏
#####2、小游戏的demo已经完成50%左右

#####遇到的问题

```javascript
    game.input.onDown.add(function()
    {
          var isUp = false;
          var pointer = game.input.activePointer;
          var currentX = pointer.clientX;
          var currentY = pointer.clientY;
           game.input.addMoveCallback(function()
          {
              game.input.onUp.add(function()
              {
                   if(!isUp && !isBounced)
                   {
                       bounce(currentX, currentY, pointer.clientX, pointer.clientY, ball);
                       isUp = true;
                       //这个isBounced是我用来代替销毁事件的变量
                       isBounced = true;
        //为什么这里删除掉所有事件之后，重新开始游戏，无法正常运行？？？
                       // game.input.destroy();
                   }
              });
           }); 
    });

```

```javascript
this.update = function() {
       if(this.ball.x < 0 || this.ball.x > game.world.width || this.ball.y > game.world.height)
       {
           isBounced = false;
           game.state.start('play');
	   }
}
```



###20161217星期六工作记录
####今天完成了投篮小游戏的demo，遇到的问题有：
#####（1）使用collide和篮框进行碰撞时，尽管把篮框immoveable设置为true，但是篮球和篮框碰撞之后篮框还是会运动；
#####（2）使用overlap自己实现了一个碰撞函数：
```javascript
if(this.ball.body.velocity.y > 0)
 {
     //碰撞函数
     game.physics.arcade.overlap(this.ball, this.left, function(){
    var temp = this.ball.x - this.left.x;
     temp /= 2;
    if(temp > 0)
    {
        this.ball.body.velocity.x = Math.abs(this.ball.body.velocity.x) + temp;
    }
    else
    {
        this.ball.body.velocity.x = - (Math.abs(this.ball.body.velocity.x) - temp);
    }
    this.ball.body.velocity.y = - this.ball.body.velocity.y;
    this.hit = true;
    }, null, this);
    //碰撞函数
    game.physics.arcade.overlap(this.ball, this.right, function(){
    var temp = this.ball.x - this.right.x;
    temp /= 2;
    if(temp > 0)
    {
        this.ball.body.velocity.x = Math.abs(this.ball.body.velocity.x) + temp;
    }
    else
    {
        this.ball.body.velocity.x = - (Math.abs(this.ball.body.velocity.x) - temp);
    }
    this.ball.body.velocity.y = - this.ball.body.velocity.y;
    this.hit = true;
 }, null, this);
this.fall();
}
```
#####但是因为篮球的图片素材是一个矩形，进行碰撞检测范围是一个矩形，这个粗略的碰撞函数在球和篮框碰撞的角度很诡异的时候，会出现一些不可描述的bug。
#####（3）如何利用篮球大小的变化做出类3D效果
```javascript
//抛出去的时候开始球大小开始变化
if(isBounced)
{
    //要保证下落的时候球不会变化（下落的时候this.star.body.velocity.y>0）
    //球最小的时候是还没抛出去的时候的一半
    var velocityOfY =  -this.ball.body.velocity.y> velocity / 2?Math.abs(this.ball.body.velocity.y):(velocity / 2);
    scale = velocityOfY / velocity;
    this.ball.height = this.ballHeight * scale;
    this.ball.width = this.ballWidth * scale;
    this.bottom.width = this.bottomWidth * scale;
    this.bottom.height = this.bottomHeight * scale;
    //scale变化率先大后小，使用（1-scale）使得影子变化慢一点
    this.bottom.y = this.bottom.y> game.world.height - 150?this.bottom.y - 200 * ( 1 - scale):game.world.height - 150; 
    this.bottom.x = this.ball.x;
}
```
#####（4）如何让星星做随机抛物线运动：
```javascript//添加旋转的属性
  for(var i = 0; i < 15; i++)
  {
      arr[i] = game.add.sprite(this.recordText.x, this.recordText.y, 'star');
      arr[i].anchor.set(0.5, 0.5);
      game.physics.enable(arr[i], Phaser.Physics.ARCADE);
      game.add.tween(arr[i]).to({angle: arr[i].angle - 360}, 1000, null, true, 0, -1, false);
  }
  //添加抛物线运动的属性
  for(var i = 0; i < 15; i ++)
  {
      arr[i].body.gravity.y = 100;
      if(i % 2 == 0)
      {
          arr[i].body.velocity.x = Math.random() * 300;
          arr[i].body.velocity.y = -Math.random() * 300;
      }
      else
      {
          arr[i].body.velocity.x = -Math.random() * 300;
          arr[i].body.velocity.y = -Math.random() * 300;
      }
  }
  //设置定时器，四秒后关闭
  game.time.events.add(4000, function(){
          this.recordText.destroy();
          for(var i = 0; i < 15; i++)
          {
              if(arr[i] != null)
                  arr[i].destroy();
          }
          var end = game.add.image(game.world.centerX, game.world.centerY, 'end');
          end.anchor.set(0.5, 0.5);
      }, this);
  //开启定时器
  game.time.events.start();
```

###20161224星期六工作记录
#####1、今天了解了使用缓存上传git的用法
#####2、今天对投篮小游戏做了以下优化：
######（1）自定义了一个圆，并使用自定义的圆来进行碰撞检测，并给球添加弹跳属性，解决了篮球和篮框碰撞时有bug的问题
```javascript
	 //画出一个圆
     //this.graphics = game.add.graphics(this.ball.x, this.ball.y);
      this.ball = game.add.graphics(this.ballSprite.x, this.ballSprite.y);
      //this.ball.beginFill(0XFFFFFF);
      this.ball.anchor.set(0.5, 0.5);
      // this.graphics.beginFill(0XFFFFFF);
      this.ball.drawCircle(0, 0, this.ballSprite.height);
      game.physics.enable(this.ball, Phaser.Physics.ARCADE);
      this.ball.body.bounce.x = 0.2;
      this.ball.body.bounce.y = 1;
      //为了能够在isUp事件中正常使用ball
      var ball = this.ball;
```
######（2）优化碰撞函数，解决了球和篮框碰撞时只会往一个方向走的bug，并让球在碰撞的时候旋转
```javascript
game.physics.arcade.overlap(this.ball, this.left, function(){
                            game.add.tween(this.ballSprite).to({angle: this.ballSprite.angle - 360}, 1000, null, true, 0, 0, false);
                        }, null, this);
game.physics.arcade.overlap(this.ball, this.right, function(){
                            game.add.tween(this.ballSprite).to({angle: this.ballSprite.angle - 360}, 1000, null, true, 0, 0, false);
                        }, null, this);
game.physics.arcade.collide(this.left, this.ball, function(){
                            if (this.ball.x > this.left.x && !this.hit) 
                            {
                                this.ball.body.velocity.x = -this.ball.body.velocity.x;
                                this.hit = true;
                            }
                        }, null, this);
game.physics.arcade.collide(this.right, this.ball, function(){
                            if (this.ball.x < this.right.x && !this.hit) 
                            {
                                this.ball.body.velocity.x = -this.ball.body.velocity.x;
                                this.hit = true;
                            }
                        }, null, this);
```

###20161225星期日工作记录
#####这是今天的内容
######（1）看完了git的教程，了解了git的功能以及一些基本指令
#####（2）由于少龙还不能看到我最新上传的代码，所以还没有进一步优化投篮小游戏


###20161228工作记录
####这是今天的内容
######1、着手进行对投篮小游戏的进一步优化，目前已经完成了50%修改任务
#####2、遇到的问题：
#####发现球在投进篮框之后，会突然停住不动，后来发现是自定义的圆和球的坐标同步语句位置有问题
```javascript
//抛出去的时候开始球大小开始变化
if(isBounced)
{
    //要保证下落的时候球不会变化（下落的时候this.star.body.velocity.y>0）
    //球最小的时候是还没抛出去的时候的一半
    var velocityOfY =  -this.ball.body.velocity.y> velocity / 2?Math.abs(this.ball.body.velocity.y):(velocity / 2);
    scale = velocityOfY / velocity;
    this.ballSprite.height = this.ballHeight * scale;
    this.ballSprite.width = this.ballWidth * scale;
    this.bottom.width = this.bottomWidth * scale;
    this.bottom.height = this.bottomHeight * scale;
    //scale变化率先大后小，使用（1-scale）使得影子变化慢一点
    this.bottom.y = this.bottom.y> game.world.height - 150?this.bottom.y - 200 * ( 1 - scale):game.world.height - 150; 
    this.bottom.x = this.ball.x;
}
//需要时刻把球和自定义圆绑定在一起，不应该把这段语句放到上面的if语句里面，
//因为当isBounced被置为false的时候，ballSprite和ball的坐标停止绑定
this.ballSprite.x = this.ball.x;
this.ballSprite.y = this.ball.y;
this.ball.height = this.ballSprite.height;
this.ball.width = this.ballSprite.width;
```
