##201702月工作记录
###20170208星期三工作记录
####这是今天的内容
#####1、尝试采用phaser的ARCEAD物理引擎来实现贪吃蛇的运动效果，遇到的问题主要有：
#####（1）如何实现拐弯效果
#####（2）不使用坐标，如何让蛇连贯运动？
#####（3）如何把之前的资源回收函数重新利用

###20170208星期四工作记录
####这是今天的内容
#####1、发现采用phaser的ARCEAD物理引擎来实现贪吃蛇的运动效果，很难实现拐弯效果，但蛇的运动很流畅
#####2、发现假如采用坐标变化来实现贪吃蛇的运动效果，很容易实现拐弯效果，但是当蛇在直线运动的时候，会很卡顿
#####3、综合以上两点，得到一个新的优化思路：当蛇在拐弯的时候，采用坐标变化来实现贪吃蛇的运动效果；当蛇不拐弯的时候，采用phaser的ARCEAD物理引擎来实现贪吃蛇的运动效果
#####4、还存在一个问题就是，拐弯结束的那一瞬间，会有明显的变化

###20170209工作记录
####这是今天上午的内容
#####1、解决了有时候蛇在吃到红包时，会出现某一块不动的bug
```javascript
 //吃到红包道具之后进行回调的函数
  this.GetRedPaper = function(prop)
  {
  	//分数加一并且更新分数条内容
  	score ++;
  	that.scoreText.text = score + " ";

  	//制造+1分效果
  	that.CreateOneScore(prop);

	var temp_body = game.add.sprite(that.dragon[g_length - 2].x + that.moveX, that.dragon[g_length - 2].y + that.moveY, 'body');
	game.physics.enable(temp_body, Phaser.Physics.ARCADE);
	
	//假如是在直行，应该有速度
	if(!g_turn)
	{
		temp_body.body.velocity.x = that.dragon[g_length - 1].body.velocity.x;
		temp_body.body.velocity.y = that.dragon[g_length - 1].body.velocity.y;
	}
  	temp_body.anchor.set(0.5, 0.5);

  	that.dragonGroup.add(temp_body);
  	that.dragon.splice(g_length - 1, 0, temp_body);
  	g_length++;
  	that.dragon[g_length - 1].x += that.moveX;
  	that.dragon[g_length - 1].y += that.moveY;
  	that.dragon[g_length - 1].bringToTop();
  	that.sleepy.bringToTop();
  	that.happy.bringToTop();

  	that.inflectedRotation.length = g_length;
  	that.inflectedRotation[g_length - 1] = that.inflectedRotation[g_length - 2];

  	that.round.length = g_length;
  	that.round[g_length - 1] = 0;
  }
```
#####2、增加了一个判断，使得随机生成的道具不会重叠
```javascript
//随机生成道具
this.CreateProp = function()
{
	//随机生成一个数字
	that.groupNumber = Math.floor(Math.random() * 9) % 3;
	var temp_positionX = (Math.random() * game.world.width * 5 / 6) + game.world.width / 12;
	var temp_positionY = (Math.random() * game.world.height * 5 / 6)  + game.world.height / 12 - game.world.height / 6;

	//假如位置发生重叠，就重新生成一次
	for(var temp_count = 0; temp_count < that.propX.length; temp_count++)
	{
		if(Math.abs(temp_positionX - that.propX[temp_count]) < 40 
			&& Math.abs(temp_positionY - that.propY[temp_count]) < 40)
		{
			that.CreateProp();
			return;
		}
	}
	//位置不重叠，记录当前的位置
	that.propX.push(temp_positionX);
	that.propY.push(temp_positionY);

	//如果已经有道具被回收了，那就不需要再生成新的道具
	if(this.ResetProp(temp_positionX, temp_positionY))
		return;

	//判断生成哪种道具
	if(that.groupNumber === 0)
	{
		var temp_prop = game.add.sprite(temp_positionX, temp_positionY, 'tea');
		that.teaGroup.add(temp_prop);
	}
	else if(that.groupNumber === 1)
	{
		temp_prop = game.add.sprite(temp_positionX, temp_positionY, 'alcohol');
		that.alcoholGroup.add(temp_prop);
	}
	else
	{
		temp_prop = game.add.sprite(temp_positionX, temp_positionY, 'redPaper', that.redPaperGroup);
		that.redPaperGroup.add(temp_prop);
	}

	//给道具添加动画
	temp_prop.anchor.set(0.5, 0.5);
	temp_prop.alpha = 0;
	if(temp_prop.width > temp_prop.height)
	{
		var temp_scale = temp_prop.width / temp_prop.height;
		temp_prop.height = 80;
		temp_prop.width = temp_prop.height * temp_scale;
	}
	else
	{
		temp_scale = temp_prop.height / temp_prop.width;
		temp_prop.width = 80;
		temp_prop.height = temp_prop.width * temp_scale;
	}
	game.add.tween(temp_prop).to({y: temp_prop.y + game.world.height / 6, alpha: 1}, 2000, Phaser.Easing.Bounce.Out,true, 0, 0, false);
	//设置道具的回收时间
	game.time.events.add(10000, function()
	{
		temp_prop.kill();
		that.RemoveProp(temp_positionX, temp_positionY);
	}, this);
	game.time.events.start();
}
```
###20170213星期一工作记录
####这是今天的内容
#####1、经过测试发现，当贪吃龙每一步之间的时间间隔和距离足够小时，视觉效果的差异会减小
#####2、根据上面的思路，调整了游戏参数，交由策划进行测试
#####3、在网上搜索贪吃蛇的实现方式，希望借鉴其他人的思路，但暂时没有发现什么好的思路，基本都是基于数组实现的。

###20170214星期二工作记录
####这是今天的内容
#####调整参数之后的效果仍达不到要求，决定取消拐弯图片，使用phaser的运动引擎来实现
####遇到的问题
#####1、发现在运动的时候改变坐标会出现误差，导致一些bug的出现，采用补偿法消除误差，但尚未彻底解决
#####2、在吃到道具改变速度的时候，会出现龙散架的bug，尚未解决