###贪吃龙项目需要注意的问题主要有：
####1、龙运动的实现：
#####（1）将龙的运动分成拐弯和直行两个部分，使用一个g_turn参数来检测此时龙处于哪种运动状态
#####（2）拐弯部分直接使用坐标数组变换方式实现，每次调用Move函数来往前行进一步；拐弯的时候记录拐弯点的坐标（也即创建的拐弯图片的坐标），当龙尾坐标与之重合的时候，拐弯结束，进入直行状态
#####（3）直行部分使用Phaser的ARCADE运动引擎实现，使用公式计算出此时龙的速度，使得龙的运动看上去不卡顿。因为龙的速度只需要设置一次，所以使用一个g_slide参数来实现只改变一次速度的功能（类似锁存器，只改变一次值之后就保存数据直到下一次改变）
####2、龙运动状态的切换：
#####龙在两种运动状态之间切换的时候，由于需要对一些参数和龙的速度进行操作，所以坐标上会产生一些误差，但是因为误差很小，加上完成一次拐弯之后，实际上就完成了一次坐标的修正，所以可以忽略不计
####3、吃到加分道具之后产生的误差
#####（1）假如是在拐弯状态下吃到加分道具之后增长一节，因为拐弯状态本来就是在操作坐标，所以不会产生误差
#####（2）假如是在直行状态下吃到加分道具，因为在创建新增的那一节身体并把这一节身体加入龙里面的时候，龙是有速度的，会不断运动，这就导致整个增长操作结束之后，势必产生一定的坐标误差
#####（3）又因为直行状态下，不操作坐标，没有对坐标进行修正，因此在从直行状态切换到拐弯状态的时候，会产生龙的身体中间出现一道空隙的bug，解决办法是，调用一个坐标修正函数Revise，根据计算出的坐标修正公示进行修正
#####（4）因为Revise函数本身也需要一定的操作，因为在执行状态下过多执行Revise函数，也会产生误差，解决方法是，添加一个g_hasGottenRedpaper参数来监测当前龙是不是处于刚吃到加分道具的待修正状态，每次吃到加分道具只对龙进行一次修正
####4、龙的越界的实现
#####（1）假如把龙运动的范围设置为游戏实例的大小，那么龙在越界的时候，边缘会有空隙出现
#####（2）解决方法是，增大龙的运动范围
```javascript
var temp_width = game.world.width + that.dragon[1].width * 3 / 2;
var temp_height = game.world.height + that.dragon[1].height * 3 / 2;
```
#####（3）需要注意的是，吃到加速道具之后，因为运动速度太快，坐标的变化会产生很大的误差，又因为当速度足够快的时候，采用坐标数组变化的方式来实现龙的运动卡顿感不强，所以龙加速的时候，无论是拐弯还是直行，我都采用坐标数组变换实现
```javascript
if(g_turn || g_speed === g_highSpeed) //蛇进行拐弯或者加速
{
     if(g_timer % g_speed == 0)
     {
	   that.Move();
     }
     g_timer++;
}
```
####5、游戏结束龙的闪烁
#####直接给龙的所有元素添加一个tween动画
```javascript
// 让整条龙闪烁
game.add.tween(that.roundGroup).to({alpha: 0}, 400, null, true, 0, 2, true);
game.add.tween(that.dragonGroup).to({alpha: 0}, 400, null, true, 0, 2, true);
game.add.tween(that.headGroup).to({alpha: 0}, 400, null, true, 0, 2, true);
```
#####可能是因为给不同元素添加动画的时候会有延迟，导致闪烁的时候，靠近龙头的一节会很明显