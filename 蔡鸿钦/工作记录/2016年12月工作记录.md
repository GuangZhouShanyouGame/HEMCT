###20161210星期六工作记录
#### *这是今天的内容。
####*上午
#####1、复习了智能社视频教程关于DOM部分内容；
#####2、咨询了分配给我做的小游戏策划的一些细节；
#####3、仔细看了一遍策划，大概地了解了一下做这个小游戏可能需要用到的一些知识；

####*下午
#####1、继续看智能社的视频教程；
#####2、现在已经看到了第22集，其中略过了18、19这两集，因为讲的是如何利用之前讲的一些知识来实现一个页面效果；


###20161213星期二工作记录
####这是今天的内容
#####上午
#####1、把视频笔记整理了一遍
#####2、重新熟悉了一下忘得差不多的phaser的一些基本用法

#####下午
#####1、开始做分配给我的投掷类小游戏
#####2、小游戏的demo已经完成50%左右

#####遇到的问题

```javascript
    game.input.onDown.add(function()
    {
          var isUp = false;
          var pointer = game.input.activePointer;
          var currentX = pointer.clientX;
          var currentY = pointer.clientY;
           game.input.addMoveCallback(function()
          {
              game.input.onUp.add(function()
              {
                   if(!isUp && !isBounced)
                   {
                       bounce(currentX, currentY, pointer.clientX, pointer.clientY, ball);
                       isUp = true;
                       //这个isBounced是我用来代替销毁事件的变量
                       isBounced = true;
        //为什么这里删除掉所有事件之后，重新开始游戏，无法正常运行？？？
                       // game.input.destroy();
                   }
              });
           }); 
    });

```

```javascript
this.update = function() {
       if(this.ball.x < 0 || this.ball.x > game.world.width || this.ball.y > game.world.height)
       {
           isBounced = false;
           game.state.start('play');
	   }
}
```


###20161217星期六工作记录
####这是今天的内容
#####1、完成了投篮小游戏demo
#####2、遇到的问题
######（1）使用collide和篮框进行碰撞时，尽管把篮框immoveable设置为true，但是篮球和篮框碰撞之后篮框还是会运动；
#####（2）使用overlap自己实现了一个碰撞函数：
```javascript
if(this.ball.body.velocity.y > 0)
 {
     //碰撞函数
     game.physics.arcade.overlap(this.ball, this.left, function(){
	     var temp = this.ball.x - this.left.x;
	      temp /= 2;
	     if(temp > 0)
	     {
	         this.ball.body.velocity.x = Math.abs(this.ball.body.velocity.x) + temp;
	     }
	     else
	     {
	         this.ball.body.velocity.x = - (Math.abs(this.ball.body.velocity.x) - temp);
	     }
	     this.ball.body.velocity.y = - this.ball.body.velocity.y;
	     this.hit = true;
    }, null, this);
    //碰撞函数
    game.physics.arcade.overlap(this.ball, this.right, function(){
	     var temp = this.ball.x - this.right.x;
	     temp /= 2;
	     if(temp > 0)
	     {
	         this.ball.body.velocity.x = Math.abs(this.ball.body.velocity.x) + temp;
	     }
	     else
	     {
	         this.ball.body.velocity.x = - (Math.abs(this.ball.body.velocity.x) - temp);
	     }
	     this.ball.body.velocity.y = - this.ball.body.velocity.y;
	     this.hit = true;
	  }, null, this);
	
	 this.fall();
}
```
#####但是因为篮球的图片素材是一个矩形，进行碰撞检测范围是一个矩形，这个粗略的碰撞函数在球和篮框碰撞的角度很诡异的时候，会出现一些不可描述的bug。
#####（3）如何利用篮球大小的变化做出类3D效果
```javascript
//抛出去的时候开始球大小开始变化
if(isBounced)
{
    //要保证下落的时候球不会变化（下落的时候this.star.body.velocity.y>0）
    //球最小的时候是还没抛出去的时候的一半
    var velocityOfY =  -this.ball.body.velocity.y> velocity / 2?Math.abs(this.ball.body.velocity.y):(velocity / 2);
    scale = velocityOfY / velocity;
    this.ball.height = this.ballHeight * scale;
    this.ball.width = this.ballWidth * scale;
    this.bottom.width = this.bottomWidth * scale;
    this.bottom.height = this.bottomHeight * scale;
    //scale变化率先大后小，使用（1-scale）使得影子变化慢一点
    this.bottom.y = this.bottom.y> game.world.height - 150?this.bottom.y - 200 * ( 1 - scale):game.world.height - 150; 
    this.bottom.x = this.ball.x;
}
```
#####（4）如何让星星做随机抛物线运动：
```javascript
//添加旋转的属性
  for(var i = 0; i < 15; i++)
  {
      arr[i] = game.add.sprite(this.recordText.x, this.recordText.y, 'star');
      arr[i].anchor.set(0.5, 0.5);
      game.physics.enable(arr[i], Phaser.Physics.ARCADE);
      game.add.tween(arr[i]).to({angle: arr[i].angle - 360}, 1000, null, true, 0, -1, false);
  }
  //添加抛物线运动的属性
  for(var i = 0; i < 15; i ++)
  {
      arr[i].body.gravity.y = 100;
      if(i % 2 == 0)
      {
          arr[i].body.velocity.x = Math.random() * 300;
          arr[i].body.velocity.y = -Math.random() * 300;
      }
      else
      {
          arr[i].body.velocity.x = -Math.random() * 300;
          arr[i].body.velocity.y = -Math.random() * 300;
      }
  }
  //设置定时器，四秒后关闭
  game.time.events.add(4000, function(){
          this.recordText.destroy();
          for(var i = 0; i < 15; i++)
          {
              if(arr[i] != null)
                  arr[i].destroy();
          }
          var end = game.add.image(game.world.centerX, game.world.centerY, 'end');
          end.anchor.set(0.5, 0.5);
      }, this);
  //开启定时器
  game.time.events.start();
```
