#2016.12月工作记录

##20161208 星期四

- **完善了游戏中奖品的拾取和使用效果。**
- **修复了飞机爆炸动画效果超出屏外,加了边界检测。**
```javascript
 if(myexplode.x < 0){
    myexplode.x = 0;
} else if( myexplode.x + myexplode.width > game.world.width){
    myexplode.x = game.world.width - myexplode.width;
} else if( myexplode.y + myexplode.height > game.world.height){
    myexplode.y = game.world.height - myexplode.height;
}
```
- **将组的生成统一为一个函数，子弹、三种敌机组的生成通过调用函数，减少了重复代码。**
```javascript
function groupInit(enemyType){
    var enemyGroup = game.add.group();
    enemyGroup.enableBody = true;
    enemyGroup.physicsBodyType = Phaser.Physics.ARCADE;
    enemyGroup.createMultiple(enemyType.count,enemyType.pic);
    enemyGroup.setAll('outOfBoundsKill',true);
    enemyGroup.setAll('checkWorldBounds',true);
    return enemyGroup;
};
this.bulletGroup = groupInit(enemyTeam.bullet);
this.enemyGroup1 = groupInit(enemyTeam.enemy1);
this.enemyGroup2 = groupInit(enemyTeam.enemy2);                    
```

##20161209 星期五
* 学习了简单的贪吃蛇游戏。不停的利用`shift`和`push`调换第一个和最后一个数组成员使贪吃蛇前进。
* 修复了模拟按钮区域不精确导致的点击区域外也会触发函数。
* 修改了模拟飞机拖动函数。
```
if (game.input.pointer1.isDown
    && game.input.x < this.plane.x / 2 + this.plane.width /2
    && game.input.x > this.plane.x / 2 - this.plane.width /2)
{
    this.plane.x = game.input.x * 2;
    this.plane.y = game.input.y * 2;
}
```

##20161212 星期一
* 上午在写一个点击消除的函数程序。
* 下午增加了飞机通用的爆炸效果，对照了一下点击消除游戏的实现代码。学习了jquery选择器的基本知识。
* 问题：原游戏点击是按钮加载。在模板下点击后消除位置不正确。还在修改。


##20161213 星期二
* 修复了游戏的一些不合理的地方。
* 问题一：子弹速度为每屏1.5秒，`bullet.body.velocity.y = -game.world.height / 2 / 1.5;`屏的高度是游戏世界高度的一半，然后再除以1.5，出来效果子弹速度明显很慢，感觉理解应该没错，但是效果不对。
* 问题二：设置敌机游戏池的数目为5，利用`game.time.events.loop`间隔一段时间调用`this.generateEnemy2`，如果间隔时间变短，敌机就会一次性生成5个，不知道代码逻辑哪里错了。
```javascript
this.generateEnemy2 = function(){
    var maxWidth = game.world.width - game.cache.getImage('enemy2').width;
    var enemy2 = this.enemyGroup2.getFirstExists(false);
    if(enemy2){
        enemy2.life = 2;
        enemy2.score = 40;
        var randomX = game.rnd.integerInRange(0, maxWidth);
        var randomY = -game.cache.getImage('enemy2').height;
        enemy2.reset(randomX , randomY );
        game.physics.enable(enemy2,Phaser.Physics.ARCADE);
        enemy2.body.velocity.y = game.world.height / 2 / 3;
    } 
};
```